// AUTOGENERATED BY private/apigen
// DO NOT EDIT.
class APIKeyInfo {
	id: string;
	projectId: string;
	partnerId: string;
	userAgent: string;
	name: string;
	createdAt: string;

	static fromJSON(v: any): APIKeyInfo {
		let o = new APIKeyInfo()
		o.id = v.id
		o.projectId = v.projectId
		o.partnerId = v.partnerId
		o.userAgent = v.userAgent
		o.name = v.name
		o.createdAt = v.createdAt

		return o
	}
}

class BucketUsageRollup {
	projectID: string;
	bucketName: string;
	totalStoredData: number;
	totalSegments: number;
	objectCount: number;
	metadataSize: number;
	repairEgress: number;
	getEgress: number;
	auditEgress: number;
	since: string;
	before: string;

	static fromJSON(v: any): BucketUsageRollup {
		let o = new BucketUsageRollup()
		o.projectID = v.projectID
		o.bucketName = v.bucketName
		o.totalStoredData = v.totalStoredData
		o.totalSegments = v.totalSegments
		o.objectCount = v.objectCount
		o.metadataSize = v.metadataSize
		o.repairEgress = v.repairEgress
		o.getEgress = v.getEgress
		o.auditEgress = v.auditEgress
		o.since = v.since
		o.before = v.before

		return o
	}
}

class CreateAPIKeyRequest {
	projectID: string;
	name: string;

	static fromJSON(v: any): CreateAPIKeyRequest {
		let o = new CreateAPIKeyRequest()
		o.projectID = v.projectID
		o.name = v.name

		return o
	}
}

class CreateAPIKeyResponse {
	key: string;
	keyInfo: APIKeyInfo;

	static fromJSON(v: any): CreateAPIKeyResponse {
		let o = new CreateAPIKeyResponse()
		o.key = v.key
		o.keyInfo = v.keyInfo

		return o
	}
}

class Project {
	id: string;
	name: string;
	description: string;
	partnerId: string;
	userAgent: string;
	ownerId: string;
	rateLimit: number;
	burstLimit: number;
	maxBuckets: number;
	createdAt: string;
	memberCount: number;
	storageLimit: number;
	bandwidthLimit: number;
	segmentLimit: number;

	static fromJSON(v: any): Project {
		let o = new Project()
		o.id = v.id
		o.name = v.name
		o.description = v.description
		o.partnerId = v.partnerId
		o.userAgent = v.userAgent
		o.ownerId = v.ownerId
		o.rateLimit = v.rateLimit
		o.burstLimit = v.burstLimit
		o.maxBuckets = v.maxBuckets
		o.createdAt = v.createdAt
		o.memberCount = v.memberCount
		o.storageLimit = v.storageLimit
		o.bandwidthLimit = v.bandwidthLimit
		o.segmentLimit = v.segmentLimit

		return o
	}
}

class ProjectInfo {
	name: string;
	description: string;
	storageLimit: number;
	bandwidthLimit: number;
	createdAt: string;

	static fromJSON(v: any): ProjectInfo {
		let o = new ProjectInfo()
		o.name = v.name
		o.description = v.description
		o.storageLimit = v.storageLimit
		o.bandwidthLimit = v.bandwidthLimit
		o.createdAt = v.createdAt

		return o
	}
}

class ResponseUser {
	id: string;
	fullName: string;
	shortName: string;
	email: string;
	partnerId: string;
	userAgent: string;
	projectLimit: number;
	isProfessional: boolean;
	position: string;
	companyName: string;
	employeeCount: string;
	haveSalesContact: boolean;
	paidTier: boolean;
	isMFAEnabled: boolean;
	mfaRecoveryCodeCount: number;

	static fromJSON(v: any): ResponseUser {
		let o = new ResponseUser()
		o.id = v.id
		o.fullName = v.fullName
		o.shortName = v.shortName
		o.email = v.email
		o.partnerId = v.partnerId
		o.userAgent = v.userAgent
		o.projectLimit = v.projectLimit
		o.isProfessional = v.isProfessional
		o.position = v.position
		o.companyName = v.companyName
		o.employeeCount = v.employeeCount
		o.haveSalesContact = v.haveSalesContact
		o.paidTier = v.paidTier
		o.isMFAEnabled = v.isMFAEnabled
		o.mfaRecoveryCodeCount = v.mfaRecoveryCodeCount

		return o
	}
}

public async /create_projects(projectInfo: console.ProjectInfo): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/projects/create/${projectInfo}`;
		const body = {
			projectInfo: console.ProjectInfo
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Creates new Project with given info')
	} catch (error) {
		console.error('something went wrong with Creates new Project with given info. Most likely blocked by browser')
public async /update/{id}_projects(id: uuid.UUID, projectInfo: console.ProjectInfo): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/projects/update/{id}/${id}/${projectInfo}`;
		const body = {
			id: uuid.UUID
			projectInfo: console.ProjectInfo
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Updates project with given info')
	} catch (error) {
		console.error('something went wrong with Updates project with given info. Most likely blocked by browser')
public async /delete/{id}_projects(id: uuid.UUID): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/projects/delete/{id}/${id}`;
		const body = {
			id: uuid.UUID
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Deletes project by id')
	} catch (error) {
		console.error('something went wrong with Deletes project by id. Most likely blocked by browser')
public async /_projects(): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/projects/`;
		const body = {
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Gets all projects user has')
	} catch (error) {
		console.error('something went wrong with Gets all projects user has. Most likely blocked by browser')
public async /bucket-rollup_projects(projectID: uuid.UUID, bucket: string, since: time.Time, before: time.Time): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/projects/bucket-rollup/${projectID}/${bucket}/${since}/${before}`;
		const body = {
			projectID: uuid.UUID
			bucket: string
			since: time.Time
			before: time.Time
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Gets project's single bucket usage by bucket ID')
	} catch (error) {
		console.error('something went wrong with Gets project's single bucket usage by bucket ID. Most likely blocked by browser')
public async /bucket-rollups_projects(projectID: uuid.UUID, since: time.Time, before: time.Time): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/projects/bucket-rollups/${projectID}/${since}/${before}`;
		const body = {
			projectID: uuid.UUID
			since: time.Time
			before: time.Time
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Gets project's all buckets usage')
	} catch (error) {
		console.error('something went wrong with Gets project's all buckets usage. Most likely blocked by browser')
public async /create_apikeys(apikeyInfo: console.CreateAPIKeyRequest): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/apikeys/create/${apikeyInfo}`;
		const body = {
			apikeyInfo: console.CreateAPIKeyRequest
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Creates new macaroon API key with given info')
	} catch (error) {
		console.error('something went wrong with Creates new macaroon API key with given info. Most likely blocked by browser')
public async /_users(): Promise<void> {
	try {
		const path = `${this.ROOT_PATH}/users/`;
		const body = {
		};
		const response = await this.http.post(path, JSON.stringify(body));
		if (response.ok) {
			return;
		}
		console.error('something went wrong with Gets User by request context')
	} catch (error) {
		console.error('something went wrong with Gets User by request context. Most likely blocked by browser')
