// Copyright (C) 2022 Storj Labs, Inc.
// See LICENSE for copying information.

package apigen

import (
	"fmt"
	"net/http"
	"os"
	"reflect"
	"sort"
	"strings"

	"github.com/zeebo/errs"
)

var tsTypeOverrides = map[string]string{
	"uuid.UUID":   "string",
	"time.Time":   "string",
	"memory.Size": "number",
	"[]uint8":     "string", // e.g. []byte
}

// getBasicReflectType dereferences a pointer and gets the basic types from slices.
func getBasicReflectType(t reflect.Type) reflect.Type {
	if t.Kind() == reflect.Ptr || t.Kind() == reflect.Slice {
		t = t.Elem()
	}
	return t
}

// tsType gets the corresponding typescript type for a provided reflect.Type.
// Input is expected to be a (non pointer) struct or primitive.
func tsType(t reflect.Type) string {
	override := tsTypeOverrides[t.String()]
	if len(override) > 0 {
		return override
	}
	switch t.Kind() {
	case reflect.Ptr:
		return tsType(t.Elem())
	case reflect.Slice:
		return tsType(t.Elem()) + "[]"
	case reflect.String:
		return "string"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return "number"
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return "number"
	case reflect.Float32, reflect.Float64:
		return "number"
	case reflect.Bool:
		return "boolean"
	case reflect.Struct:
		return t.Name()
	default:
		//panic("unhandled type: " + t.Name())

		return ""
	}
}

// MustWriteTS writes generated TypeScript code into a file.
func (a *API) MustWriteTS(path string) {
	f := newTSGenFile(path, a)

	err := f.generateTS()
	if err != nil {
		panic(errs.Wrap(err))
	}

	err = f.write()
	if err != nil {
		panic(errs.Wrap(err))
	}
}

type tsGenFile struct {
	result       string
	path         string
	types        map[reflect.Type][]reflect.Type
	typeList     []reflect.Type
	typesWritten map[reflect.Type]bool
	api          *API
}

func newTSGenFile(filepath string, api *API) *tsGenFile {
	f := &tsGenFile{
		path:         filepath,
		types:        make(map[reflect.Type][]reflect.Type),
		typesWritten: make(map[reflect.Type]bool),
		api:          api,
	}

	f.p("// AUTOGENERATED BY private/apigen")
	f.p("// DO NOT EDIT.")

	return f
}

func (f *tsGenFile) p(format string, a ...interface{}) {
	f.result += fmt.Sprintf(format+"\n", a...)
}

func (f *tsGenFile) write() error {
	return os.WriteFile(f.path, []byte(f.result), 0644)
}

func (f *tsGenFile) getStructsFromType(t reflect.Type) {
	t = getBasicReflectType(t)
	override := tsTypeOverrides[t.String()]
	if len(override) > 0 {
		return
	}

	if _, ok := f.types[t]; !ok {
		f.typeList = append(f.typeList, t)
		f.types[t] = []reflect.Type{}
	}

	// if it is a struct, get any types needed from the fields
	if t.Kind() == reflect.Struct {
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			f.getStructsFromType(field.Type)
			deps := f.types[t]
			deps = append(deps, getBasicReflectType(field.Type))
			f.types[t] = deps
		}
	}

}

func (f *tsGenFile) generateTS() error {
	for _, group := range f.api.EndpointGroups {
		for _, method := range group.endpoints {
			if method.Request != nil {
				reqType := reflect.TypeOf(method.Request)
				f.getStructsFromType(reqType)
			}
			if method.Response != nil {
				resType := reflect.TypeOf(method.Response)
				f.getStructsFromType(resType)
			}
			if len(method.QueryParams) > 0 {
				for _, p := range method.QueryParams {
					t := getBasicReflectType(p.Type)
					f.getStructsFromType(t)
				}
			}
		}
	}

	fmt.Println("all types")
	sort.Slice(f.typeList, func(i, j int) bool {
		return strings.Compare(f.typeList[i].Name(), f.typeList[j].Name()) < 0
	})

	for _, t := range f.typeList {
		f.emitStruct(t)
	}
	fmt.Println("end")

	// TODO: this should be at the top of the file.
	f.p("import { HttpClient } from '@/utils/httpClient'")

	// loop over endpoints
	for _, group := range f.api.EndpointGroups {
		f.p("export class %sHttpApi {", group.Prefix)
		f.p("\tprivate readonly http: HttpClient = new HttpClient();")
		// TODO: get the full path from the api definition struct rather than hardcoding it
		f.p("\tprivate readonly ROOT_PATH: string = '/api/v0/%s';", group.Prefix)
		f.p("")
		for _, method := range group.endpoints {
			var funcArgs string
			var reqParams string
			for i, p := range method.QueryParams {
				if i > 0 {
					funcArgs += ", "
				}
				funcArgs += p.Name + ": " + tsType(p.Type)
				reqParams += fmt.Sprintf("/${%s}", p.Name)
			}

			returnType := "void"
			if method.Response != nil {
				returnType = getBasicReflectType(reflect.TypeOf(method.Response)).Name()
			}
			f.p("\tpublic async %s(%s): Promise<%s> {", method.RequestName, funcArgs, returnType)
			f.p("\t\ttry {")

			pathWithoutParams, _, _ := strings.Cut(method.Path, "{")

			path := fmt.Sprintf("${this.ROOT_PATH}%s", pathWithoutParams+reqParams)
			path = strings.Replace(path, "//", "/", -1)

			f.p("\t\t\tconst path = `%s`;", path)

			f.p("\t\t\tconst body = {")
			// TODO: insert endpoint request
			f.p("\t\t\t};")
			if method.Method == http.MethodGet || method.Method == http.MethodDelete {
				f.p("\t\t\tconst response = await this.http.%s(path);", strings.ToLower(method.Method))
			} else {
				f.p("\t\t\tconst response = await this.http.%s(path, JSON.stringify(body));", strings.ToLower(method.Method))
			}
			f.p("\t\t\tif (response.ok) {")
			rtnStmt := "return"
			if method.Response != nil {
				rtnStmt += fmt.Sprintf(" response.json().then((body) => body as %s)", returnType)
			}
			rtnStmt += ";"
			f.p("\t\t\t\t%s", rtnStmt)
			f.p("\t\t\t}")
			f.p("\t\t\tthrow new Error(`something went wrong with %s`)", method.Description)
			f.p("\t\t} catch (error) {")
			f.p("\t\t\tthrow new Error(`something went wrong with %s. Most likely blocked by browser`);", method.Description)
			f.p("\t\t}")
			f.p("\t}\n")
		}
		f.p("}")
	}

	return nil
}

func (f *tsGenFile) emitStruct(t reflect.Type) {
	override := tsTypeOverrides[t.String()]
	if len(override) > 0 {
		return
	}
	if f.typesWritten[t] {
		return
	}
	if t.Kind() != reflect.Struct {
		// TODO: handle slices
		return
	}

	for _, d := range f.types[t] {
		if f.typesWritten[d] {
			continue
		}
		f.emitStruct(d)
	}

	f.p("class %s {", t.Name())
	defer f.p("}\n")

	var allAttributes []string
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		attributes := strings.Fields(field.Tag.Get("json"))
		if len(attributes) == 0 || attributes[0] == "" {
			panic(t.Name() + " missing json declaration")
		}
		if attributes[0] == "-" {
			continue
		}
		allAttributes = append(allAttributes, attributes[0])
		f.p("\t%s: %s;", attributes[0], tsType(field.Type))
	}

	f.p("\n\tstatic fromJSON(v: any): %s {", t.Name())
	f.p("\t\tlet o = new %s()", t.Name())
	for _, a := range allAttributes {
		f.p("\t\to.%s = v.%s", a, a)
	}
	f.p("\n\t\treturn o")
	f.p("\t}")
	f.typesWritten[t] = true
}
